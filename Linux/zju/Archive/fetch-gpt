#!/bin/bash

dayback=30

function get_last_job {
    qstat -a | tail -1 | awk -F. '{print $1}'
}

function get_running_jobs {
    qstat -r | grep " R "
}

function get_tracejob_info {
    local job_id="$1"
    tracejob "$job_id" -n "$dayback" -slmq
}

OUTPUT="log_28"
echo "JOBID QUEUE QUEUE_TIME RUN_TIME USER" > "$OUTPUT"

total=0
qtime=0
get_running_jobs > running_jobs_list

while read -r line; do
    read -r ii user queue hour min <<< $(echo "$line" | awk '{print $1, $2, $3, $11}' | awk -F: '{print $1, $2, $3, $4, $5}')
    rtime=$(echo "scale=2; $hour + $min / 60" | bc -l)
    total=$(echo "scale=1; $total + $rtime" | bc -l)
    echo "$ii $queue $qtime $rtime $user" >> "$OUTPUT"
done < running_jobs_list

rm running_jobs_list
echo "Currently Running: $total hrs"

LAST_JOB=$(get_last_job)

for (( ii=26315; ii<=LAST_JOB; ii++ )); do
    tracejob_info=$(get_tracejob_info "$ii")

    check=$(echo "$tracejob_info" | grep resources_used.walltime)
    if [[ "${check}" ]]; then
        read -r hour min <<< $(echo "$tracejob_info" | grep resources_used.walltime | sed -n -e 's/.*resources_used.walltime=//p' | awk '{print $1}' | awk -F: '{print $1,$2}')
        rtime=$(echo "scale=1; $hour + $min / 60" | bc -l)
        if (( $(echo "$rtime < 1" | bc -l) )); then
            continue
        else
            queue=$(echo "$tracejob_info" | grep queue | head -1 | sed -n -e 's/.*queue=//p' | awk '{print $1}')
            user=$(echo "$tracejob_info" | grep user | head -1 | sed -n -e 's/.*user=//p' | awk '{print $1}')
            A=$(echo "$tracejob_info" | grep qtime | head -1 | sed -n -e 's/.*qtime=//p' | awk '{print $1}')
            B=$(echo "$tracejob_info" | grep start | head -1 | sed -n -e 's/.*start=//p' | awk '{print $1}')
            qtime=$(echo "scale=1; ($B - $A)/3600" | bc -l)
            echo "$ii $queue $qtime $rtime $user" >> "$OUTPUT"
        fi
    else
        continue
    fi
done
